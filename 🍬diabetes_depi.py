# -*- coding: utf-8 -*-
"""üç¨Diabetes DEPI

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/#fileId=https%3A//storage.googleapis.com/kaggle-colab-exported-notebooks/rezk1834/diabetes-depi.e070c628-47ce-4fd0-94a6-c553c41c8998.ipynb%3FX-Goog-Algorithm%3DGOOG4-RSA-SHA256%26X-Goog-Credential%3Dgcp-kaggle-com%2540kaggle-161607.iam.gserviceaccount.com/20250511/auto/storage/goog4_request%26X-Goog-Date%3D20250511T070250Z%26X-Goog-Expires%3D259200%26X-Goog-SignedHeaders%3Dhost%26X-Goog-Signature%3D26853167821ba431b1515b5391c593952717c07cc3d3d8c7dd20391fe54532f06eef48e17986d1fef4eb1fe587ce3fe6f3e93bb2514924c49dbde74e7fbacd43a8218ef34f8a6127fb7d4d1225ed58270e9e43887447341acd07eabbc3c7cab9c473fc036026871201395f3bfc1a90d30e93241f9dfffd8c5fa1d97703af5a23423e3af06c7223876ae8dc70b1797b09b640c834756f987055abc2f4573d814bf9de6f83c1f8137710d0995f15b687960841ee8afe74d3d5a0a96c09fdc90d6f99620731b26b29ce0643112f923f1603e7c727268b480a6abe5cd6b36ba9c6fb634b1d4fe74bda8a7554bb901c60b28d1bb02dc12be027634ce706a5241c97d7

### Import the libraries
"""

import warnings
warnings.filterwarnings('ignore')

# Import Neccessary libraries
import numpy as np
import pandas as pd

# Import Visualization libraries
import matplotlib.pyplot as plt
import seaborn as sns

#Import Model
from sklearn.model_selection import train_test_split, GridSearchCV
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
from sklearn.pipeline import Pipeline

#Import Sampler libraries
from imblearn.over_sampling import SMOTE
from imblearn.under_sampling import RandomUnderSampler
from imblearn.pipeline import Pipeline as imbPipeline

# Set the decimal format
pd.options.display.float_format = "{:.2f}".format

"""### Input the data"""

df = pd.read_csv("diabetes_prediction_dataset.csv")

df.head()

"""# EXPLORATORY DATA ANALYSIS

## 1. Data Quality

### Handling Duplicates
"""

# Handle duplicates
duplicate_rows_data = df[df.duplicated()]
print("number of duplicate rows: ", duplicate_rows_data.shape)

df = df.drop_duplicates()

"""### Uniqueness"""

# Loop through each column and count the number of distinct values
for column in df.columns:
    num_distinct_values = len(df[column].unique())
    print(f"{column}: {num_distinct_values} distinct values")

"""### Missing Values"""

# Checking null values
print(df.isnull().sum())

# Remove Unneccessary value [0.00195%]
df = df[df['gender'] != 'Other']

"""### Describe the Data"""

df.describe().style.format("{:.2f}")

"""## 2. Univariate Analysis

### Histogram for age
"""

# Histogram for age
plt.hist(df['age'], bins=30, edgecolor='black')
plt.title('Age Distribution')
plt.xlabel('Age')
plt.ylabel('Count')
plt.show()
plt.savefig('Age Distribution.png', dpi=300, bbox_inches='tight')

"""### Bar plot for gender"""

# Bar plot for gender
sns.countplot(x='gender', data=df)
plt.title('Gender Distribution')
plt.show()
plt.savefig('Gender Distribution.png', dpi=300, bbox_inches='tight')

"""### Distribution plot for BMI"""

# Distribution plot for BMI
sns.distplot(df['bmi'], bins=30)
plt.title('BMI Distribution')
plt.show()
plt.savefig('BMI Distribution.png', dpi=300, bbox_inches='tight')

"""###  Count plots for binary variables"""

# Count plots for binary variables
for col in ['hypertension', 'heart_disease', 'diabetes']:
    sns.countplot(x=col, data=df)
    plt.title(f'{col} Distribution')
    plt.show()
    plt.savefig('col Distribution.png', dpi=300, bbox_inches='tight')

"""###  Count plot for smoking history"""

# Count plot for smoking history
sns.countplot(x='smoking_history', data=df)
plt.title('Smoking History Distribution')
plt.show()
plt.savefig('Smoking History Distribution.png', dpi=300, bbox_inches='tight')

"""## 3.Bivariative Analysis
### Boxplot BMI vs Diabetes classification
"""

# Boxplot BMI vs Diabetes classification
sns.boxplot(x='diabetes', y='bmi', data=df)
plt.title('BMI vs Diabetes')
plt.show()
plt.savefig('BMI vs Diabetes.png', dpi=300, bbox_inches='tight')

"""### Boxplot Age vs Diabetes classification"""

# Boxplot Age vs Diabetes classification
sns.boxplot(x='diabetes', y='age', data=df)
plt.title('Age vs Diabetes')
plt.show()
plt.savefig('Age vs Diabetes.png', dpi=300, bbox_inches='tight')

"""###  Count plot of gender vs diabetes"""

# Count plot of gender vs diabetes
sns.countplot(x='gender', hue='diabetes', data=df)
plt.title('Gender vs Diabetes')
plt.show()
plt.savefig('Gender vs Diabetes.png', dpi=300, bbox_inches='tight')

"""###  Boxplot HbA1c level vs Diabetes classification"""

# Boxplot HbA1c level vs Diabetes classification
sns.boxplot(x='diabetes', y='HbA1c_level', data=df)
plt.title('HbA1c level vs Diabetes')
plt.show()
plt.savefig('HbA1c level vs Diabetes.png', dpi=300, bbox_inches='tight')

"""### Boxplot blood glucose level vs Diabetes classification"""

# Boxplot blood glucose level vs Diabetes classification
sns.boxplot(x='diabetes', y='blood_glucose_level', data=df)
plt.title('Blood Glucose Level vs Diabetes')
plt.show()
plt.savefig('Blood Glucose Level vs Diabetes.png', dpi=300, bbox_inches='tight')

"""###  Pair plot for numeric features"""

# Pair plot for numeric features
sns.pairplot(df, hue='diabetes')
plt.show()
plt.savefig('pairplot.png', dpi=300, bbox_inches='tight')

"""##  4. Multivariate analysis

###  Scatterplot Age vs BMI colored by Diabetes classification
"""

# Scatterplot Age vs BMI colored by Diabetes classification
sns.scatterplot(x='age', y='bmi', hue='diabetes', data=df)
plt.title('Age vs BMI')
plt.show()
plt.savefig('Age vs BMI.png', dpi=300, bbox_inches='tight')

"""###  Violin plot of BMI against diabetes classification split by gender"""

# Violin plot of BMI against diabetes classification split by gender
sns.violinplot(x='diabetes', y='bmi', hue='gender', split=True, data=df)
plt.title('BMI vs Diabetes split by Gender')
plt.show()
plt.savefig('BMI vs Diabetes split by Gender.png', dpi=300, bbox_inches='tight')

"""### Interaction between gender, BMI and diabetes"""

# Interaction between gender, BMI and diabetes
sns.boxplot(x='diabetes', y='bmi', hue='gender', data=df)
plt.title('BMI Distribution by Diabetes Status and Gender')
plt.show()
plt.savefig('BMI Distribution by Diabetes Status and Gender.png', dpi=300, bbox_inches='tight')

"""### Interaction between gender, Age and diabetes"""

# Interaction between gender, Age and diabetes
sns.boxplot(x='diabetes', y='age', hue='gender', data=df)
plt.title('Age Distribution by Diabetes Status and Gender')
plt.show()
plt.savefig('Age Distribution by Diabetes Status and Gender.png', dpi=300, bbox_inches='tight')

"""# CORRELATION

###  Data preparation
"""

# Define a function to map the existing categories to new ones
def recategorize_smoking(smoking_status):
    if smoking_status in ['never', 'No Info']:
        return 'non-smoker'
    elif smoking_status == 'current':
        return 'current'
    elif smoking_status in ['ever', 'former', 'not current']:
        return 'past_smoker'

# Apply the function to the 'smoking_history' column
df['smoking_history'] = df['smoking_history'].apply(recategorize_smoking)

# Check the new value counts
print(df['smoking_history'].value_counts())

data = df.copy()

"""### Encoding"""

def perform_one_hot_encoding(df, column_name):
    # Perform one-hot encoding on the specified column
    dummies = pd.get_dummies(df[column_name], prefix=column_name)

    # Drop the original column and append the new dummy columns to the dataframe
    df = pd.concat([df.drop(column_name, axis=1), dummies], axis=1)

    return df

# Perform one-hot encoding on the gender variable
data = perform_one_hot_encoding(data, 'gender')

# Perform one-hot encoding on the smoking history variable
data = perform_one_hot_encoding(data, 'smoking_history')

"""### Correlation Matrix"""

# Compute the correlation matrix
correlation_matrix = data.corr()
#Graph I.
plt.figure(figsize=(15, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', linewidths=0.5, fmt='.2f')
plt.title("Correlation Matrix Heatmap")
plt.show()


#Graph II
# Create a heatmap of the correlations with the target column
corr = data.corr()
target_corr = corr['diabetes'].drop('diabetes')

# Sort correlation values in descending order
target_corr_sorted = target_corr.sort_values(ascending=False)

sns.set(font_scale=0.8)
sns.set_style("white")
sns.set_palette("PuBuGn_d")
sns.heatmap(target_corr_sorted.to_frame(), cmap="coolwarm", annot=True, fmt='.2f')
plt.title('Correlation with Diabetes')
plt.show()
plt.savefig('Correlation with Diabetes.png', dpi=300, bbox_inches='tight')

"""# PREDICTIVE ANALYSIS

## 1. Class Imbalance
"""

# Count plot for the 'diabetes' variable
sns.countplot(x='diabetes', data=df)
plt.title('Diabetes Distribution')
plt.show()
plt.savefig('Diabetes Distribution.png', dpi=300, bbox_inches='tight')

# Define resampling
over = SMOTE(random_state=42)

"""## 2.Preprocessing : Scaler"""

# Define preprocessor
preprocessor = ColumnTransformer(
    transformers=[
        ('num', StandardScaler(), ['age', 'bmi', 'HbA1c_level', 'blood_glucose_level','hypertension','heart_disease']),
        ('cat', OneHotEncoder(), ['gender','smoking_history'])
    ])

# Split data into features and target variable
X = df.drop('diabetes', axis=1)
y = df['diabetes']

X_preprocessed = preprocessor.fit_transform(X)

X_resampled, Y_Resampled = over.fit_resample(X_preprocessed, y)

X_train, X_test, y_train, y_test = train_test_split(X_resampled, Y_Resampled, test_size=0.2, random_state=42)

"""## 3. Model Building and Hyperparameter Tuning"""

# Define the hyperparameters and the values we want to test
param_grid = {
    'classifier__n_estimators': [50, 100, 200],
    'classifier__max_depth': [None, 10, 20],
    'classifier__min_samples_split': [2, 5, 10],
    'classifier__min_samples_leaf': [1, 2, 4]
}

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

rf_classifier = RandomForestClassifier(random_state=42)
rf_classifier.fit(X_train, y_train)

# Make predictions on the test set
y_pred = rf_classifier.predict(X_test)

# Evaluate the model
accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")
print(classification_report(y_test, y_pred))
print(confusion_matrix(y_test, y_pred))

from xgboost import XGBClassifier
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# Create and train the XGBoost model
xgb_model = XGBClassifier(use_label_encoder=False, eval_metric='logloss', random_state=42)
xgb_model.fit(X_train, y_train)

# Make predictions
y_pred_xgb = xgb_model.predict(X_test)

# Evaluate performance
print("XGBoost Accuracy:", accuracy_score(y_test, y_pred_xgb))
print(classification_report(y_test, y_pred_xgb))
print("Confusion Matrix:\n", confusion_matrix(y_test, y_pred_xgb))

"""## 4. Confusion Matrix"""

# Plot confusion matrix
cm = confusion_matrix(y_test, y_pred)
plt.figure(figsize=(8, 6))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues')
plt.title('Confusion Matrix')
plt.xlabel('Predicted')
plt.ylabel('True')

# ‚úÖ Save BEFORE showing the plot
plt.savefig('confusion_matrix.png', dpi=300, bbox_inches='tight')
plt.show()

onehot_columns = list(
    preprocessor.named_transformers_['cat']
    .get_feature_names_out(['gender', 'smoking_history'])
)
numeric_features = ['age', 'bmi', 'HbA1c_level', 'blood_glucose_level', 'hypertension', 'heart_disease']
feature_names = numeric_features + onehot_columns

# Get feature importances from the trained XGBoost model
importances = xgb_model.feature_importances_

# Create a DataFrame
importance_df = pd.DataFrame({
    'Feature': feature_names,
    'Importance': importances
}).sort_values(by='Importance', ascending=False)

# Plot feature importances
plt.figure(figsize=(12, 8))
sns.barplot(x='Importance', y='Feature', data=importance_df)
plt.title('XGBoost Feature Importances')
plt.tight_layout()

# Save and show
plt.savefig('xgb_feature_importances.png', dpi=300, bbox_inches='tight')
plt.show()

import joblib

# Save the trained XGBoost model to a file
joblib.dump(xgb_model, 'xgboost_diabetes_model.pkl')
print("‚úÖ XGBoost model saved as 'xgboost_diabetes_model.pkl'")

# Save the fitted preprocessor (e.g., scaling and encoding)
joblib.dump(preprocessor, 'preprocessor_pipeline.pkl')
print("‚úÖ Preprocessing pipeline saved as 'preprocessor_pipeline.pkl'")